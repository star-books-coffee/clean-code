# 11장 : 시스템
“복잡성은 죽음이다. 개발에게서 생기를 앗아가며, 제품을 계획하고 기획하고
제작하고 테스트하기 어렵게 만든다.”

## 📌 도시를 세운다면?
- 도시가 돌아가는 이유는 많은 사람이 분업해 작업하기 때문
- 또 다른 이유는 `적절한 추상화`와 `모듈화` 때문
- 소프트웨어 팀도 도시처럼 구성하지만 막상 관심사의 분리와 추상화를 이뤄내지 못함.
- 시스템 수준에서도 깨끗함을 유지하는 방법을 찾아보자.

## 📌 시스템 제작과 시스템 사용을 분리하라

우선 제작과 사용은 아주 다르다는 사실을 명심한다.

- 소프트웨어 시스템은 준비과정과 런타임 로직을 분리해야 한다.

**시작 단계**는 모든 애플리케이션이 풀어야 할 **관심사(concern)**이다.

- 관심사 분리는 우리 분야에서 가장 오래되고 중요한 설계 기법 중 하나다.
- 대다수 사용하는 나쁜 예
    
    ```java
    public Service getService() {
    	if (service == null)
    		service = new MyServiceImpl(...); // 모든 상황에 적합한 기본값일까?
    	return service;
    }
    ```
    
- 초기화 지연 혹은 계산 지연이라는 기법
    - 장점은 여러가지가 있지만 MyServiceImpl과 생성자 인수에 명시적으로 의존함.
    - MyServiceImpl 객체를 전혀 사용하지 않더라도 의존성을 해결하지 않으면 컴파일이 안된다.
    - MyServiceImpl이 무거운 객체라면 테스트 전용객체를 service 필드에 할당해야 함.
    - 일반 런타임 로직에 객체 생성 로직을 섞어 놓은 탓에 모든 실행 경로도 테스트해야 한다.
        
        ⇒ 단일 책임 원칙 위반
        
    - MyServiceImpl이 모든 상황에 적합한 객체인지 모른다.
- 체계적이고 탄탄한 시스템을 만들고 싶다면 이렇게 짜면 안됨.
    - 좀스럽고 손쉬운 기법으로 모듈성을 깨지 말자.
        - 객체를 생성하거나 의존성을 연결할 때에도 마찬가지
    - 설정 논리는 일반 실행 논리와 분리해야 모듈성이 높아짐.
        
        무슨 소리일까……… 모르겠다…
        

### Main 분리