## 📌 들어가며

- 아래 소개하는 목록에서 리팩토링의 저자 마틴이 맡은 냄새와 클린코드 저자가 맡은 냄새를 추가했다

## 📌 주석

### 부적절한 정보

- 다른 시스템에 저장할 정보는 주석으로 적절하지 못하다
- 예를 들어 변경 이력은 소스코드만 번잡하게 만든다
- 일반적으로 작성자, 최종 수정일, SPR 번호와 같은 메타 정보만 주석으로 넣는다

### **쓸모 없는 주석**

- 오래된 주석, 엉뚱한 주석, 잘못된 주석은 아예 달지 않는 편이 가장 좋고, 쓸모 없어진 주석은 재빨리 삭제하라.

### 중복된 주석

- 코드만으로 충분한데 구구절절 설명하는 주석은 중복된 주석이다.

### 성의 없는 주석

- 주석을 달 참이라면 시간 들여 최대한 멋지게 작성한다.

### 주석 처리된 코드

- 주석으로 처리된 코드를 발견하면 즉각 지워버려라!

## 📌 환경

### 여러 단계로 빌드해야 한다

- 한 명령으로 전체를 체크아웃해서 한 명령으로 빌드할 수 있어야 한다.

### 여러 단계로 테스트해야 한다

- 모든 단위 테스트는 한 명령으로 돌려야 한다.

## 📌 함수

### 너무 많은 인수

- 함수 인수는 아예 없으면 가장 좋고, 넷 이상이 넘어가면 그 가치가 아주 의심스러우므로 최대한 피한다.

### 출력 인수

- 함수에서 뭔가의 상태를 변경해야 한다면 출력 인수를 쓰지 말고 함수가 속한 객체의 상태를 변경한다.

### 플래그 인수

- boolean 인수는 함수가 여러 기능을 수행한다는 명백한 증거이므로 피해야 마땅하다.

### 죽은 함수

- 아무도 호출하지 않는 함수는 삭제한다.

## 📌 일반

### 한 소스 파일에 여러 언어를 사용한다

- 이상적으로는 소스 파일 하나에 언어 하나만 사용하는 방식이 가장 좋다.

### 당연한 동작을 구현하지 않는다.

- 당연한 동작을 구현하지 않으면 코드를 읽거나 사용하는 사람이 더 이상 함수만으로 함수 기능을 직관적으로 예상하기 어렵다.
- ex) 요일 문자열에서 요일을 나타내는 enum으로 변환하는 함수의 경우 대소문자는 당연히 구분하지 않으라 기대한다거나, 일반적으로 쓴느 요일 약어도 올바로 변환하리라 기대

### 안전 절차 무시

- 컴파일러 경고 문자 무시, 테스트 케이스 제껴두기 등의 행동 금지

### 중복

- 코드에서 중복을 발견할 때마다 추상화할 기회로 간주하라.

### 추상화 수준이 올바르지 못하다

- 모든 저차원 개념은 파생 클래스에, 모든 고차원 개념은 기초 클래스에 넣는다.

### 기초 클래스가 파생 클래스에 의존한다

- 일반적으로 기초 클래스는 파생 클래스를 아예 몰라야 마땅하다.
- 물론 예외는 있다.

### 과도한 정보

- 잘 정의된 인터페이스는 많은 함수를 제공하지 않는다 → 그래서 결합도가 낮다
- 클래스나 모듈 인터페이스에 노출할 함수를 제한할 줄 알아야 한다.

### 죽은 코드

- 불가능한 조건을 확인하는 if문, throw문이 없는 try문에서 catch 블록, 아무도 호출하지 않는 유틸리티 함수, switch/case 문에서 불가능한 case 조건

### 수직 분리

- 변수와 함수는 사용되는 위치에 가깝게 정의한다.
- 비공개 함수는 처음으로 호출한 직후에 정의한다.

### 일관성 부족

- 어떤 개념을 특정한 방식으로 구현했다면 유사한 개념도 같은 방식으로 구현

### 잡동사니

- 비어있는 기본 생성자가 왜 필요한가?
- 아무도 사용하지 않는 변수, 함수, 필요 없는 주석 등을 삭제하라.

### 인위적 결합

- 서로 무관한 개념을 인위적으로 결합하지 않는다.
- 예를 들어 일반적인 enum은 특정 클래스에 속할 이유가 없다.
- 함수, 상수, 변수를 선언할 때는 시간 들여 올바른 위치를 고민한다.

### 기능 욕심

- 클래스 메서드는 자기 클래스의 변수와 함수에 관심을 가져야지 다른 클래스의 변수와 함수에 관심을 가져서는 안된다.

### 선택자 인수

- WeeklyPay(false)와 같은 선택자 인수를 피해라.
- boolean 인수 뿐만 아니라 enum, int 등 함수 동작을 제어하려는 인수는 하나 같이 바람직하지 않다.
- 일반적으로, 인수를 넘겨 동작을 선택하는 대신 새로운 함수를 만드는 편이 좋다.

### 모호한 의도

- 코드를 짤 때는 의도를 최대한 분명히 밝힌다.

### 잘못 지운 책임

- 코드는 독자가 자연스럽게 기대할 위치에 배치한다.(최소 놀람의 원칙)

### 부적절한 static 함수

- 일반적으로 static 함수보다 인스턴스 함수가 더 좋다.
- 반드시 static 함수로 정의해야겠다면 재정의할 가능성은 없는지 꼼꼼히 따져본다.

### 서술적 변수

- 프로그램 가독성을 높이는 가장 효과적인 방법 중 하나가 계산을 여러 단계로 나누고 중간 값으로 서술적인 변수 이름을 사용하는 방법
- 서술적인 변수 이름은 많이 써도 괜찮다.

### 이름과 기능이 일치하는 함수

- add → addDaysTo 혹은 increaseByDays라는 이름이 좋다.
- 이름만으로 분명하지 않기에 구현을 살피거나 문서를 뒤적여야 한다면 더 좋은 이름으로 바꾸거나 더 좋은 이름을 붙이기 쉽도록 기능을 정리해야 한다.

### 알고리즘을 이해해라

- 구현이 끝났다고 선언하기 전에 함수가 돌아가는 방식을 확실히 이해하는지 확인하라.

### 논리적 의존성은 물리적으로 드러내라

- 한 모듈이 다른 모듈에 의존한다면 물리적인 의존성도 있어야 한다. 논리적인 의존성만으로는 부족하다.

### If/Else 혹은 Switch/Case 문보다 다형성을 사용하라

- switch문 하나 규칙 : 선택 유형 하나에는 switch 문을 한 번만 사용한다. 같은 선택을 수행하는 다른 코드에서는 다형성 객체를 생성해 switch 문을 대신한다.

### 표준 표기법에 따르라

- 팀이 정한 표준은 팀원들 모두가 따라야 한다.

### 매직 숫자는 명명된 상수로 교체하라

### 정확하라

- 코드에서 뭔가를 결정할 때는 정확히 결정한다. 결정을 내리는 이유와 예외를 처리할 방법을 분명히 알아야 한다.

### 관례보다 구조를 사용하라

- 설계 결정을 강제할 때는 규칙보다 관례를 사용한다.

### 조건을 캡슐화하라

### 부정 조건은 피하라

### 함수는 한 가지만 해야 한다

### 숨겨진 시간적인 결합

- 시간적인 결합을 숨겨서는 안된다.
- 함수를 짤 때는 함수 인수를 적절히 배치해 함수가 호출되는 순서를 명백히 드러낸다.

### 일관성을 유지하라

- 코드 구조를 잡을 때는 이유를 고민하라
- 그리고 그 이유를 코드 구조로 명백히 표현하라

### 경계 조건을 캡슐화하라

- 코드 여기저기에 +1이나 -1을 흩어놓지 않는다.
- 경계 조건은 한 곳에서 별도로 처리한다.

### 함수는 추상화 수준을 한 단계만 내려가야 한다

- 함수 내 모든 문장은 추상화 수준이 동일해야 한다

### 설정 정보는 최상위 단계에 둬라

### 추이적 탐색을 피하라

- 일반적으로 한 모듈은 주변 모듈을 모를수록 좋다. (디미터의 법칙)

## 📌 자바

### 긴 import 목록을 피하고 와일드 카드를 사용하라

### 상수는 상속하지 않는다

### 상수 vs Enum

- enum을 적극 사용하라

## 📌 이름

### 서술적인 이름을 사용하라

### 적절한 추상화 수준에서 이름을 선택하라

### 가능하다면 표준 명명법을 사용하라

### 명확한 이름

- 함수나 변수의 목적을 명확히 밝히는 이름을 선택한다.

### 긴 범위는 긴 이름을 사용하라

### 인코딩을 피하라

### 이름으로 부수 효과를 설명하라

## 📌 테스트

### 불충분한 테스트

- 테스트 케이스는 잠재적으로 깨질 만한 부분을 모두 테스트해야 한다.

### 커버리지 도구를 사용하라!

### 사소한 테스트를 건너뛰지 마라

### 무시한 테스트는 모호함을 뜻한다

### 경계 조건을 테스트하라

### 버그 주변은 철저히 테스트하라

### 실패 패턴을 살펴라

### 테스트 커버리지 패턴을 살펴라

### 테스트는 빨라야 한다

## 📌 결론

- 이 목록이 완전하다 말하기는 어렵지만 완전한 목록이 가능하지도 않다.
- 전문가 정신과 장인 정신은 가치에서 나온다. 그 가치에 기반한 규율과 절제가 필요하다.
