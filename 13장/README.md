# 13장 : 동시성
## 📌 들어가며

> 객체는 처리의 추상화다. 스레드는 일정의 추상화다.
- 동시성과 깔끔한 코드는 양립하기 아-주 어려움.
- 단일 스레드와 다중 스레드 코드 모두 짜기는 쉽고 잘 돌아가지만… 그건… 시스템이 부하 받기 전까지임.
- 이 장에서 배울 내용 : 여러 스레드 동시 돌리는 것의 어려움과 대처 및 깨끗한 코드 작성하기

## 📌 동시성이 필요한 이유

- 동시성 : 결합을 없애는 전략
    - 무엇(what)과 언제(when)을 분리하는 전략
    - 스레드가 하나인 프로그램 → 무엇과 언제가 서로 밀접
- 무엇과 언제를 분리하면 애플리케이션 구조와 효율이 극적으로 나아짐.
- 예시 : 서블릿 모델의 동시성
    - 서블릿은 웹 혹은 EJB 컨테이너라는 우산 아래서 돌아감.
    - 컨테이너는 동시성을 부분적으로 관리
    - 웹 요청이 들어올 때마다 웹 서버는 비동기식으로 서블릿을 실행
    - 각 서블릿 스레드는 다른 서블릿 스레드와 무관하게 자신만의 세상에서 돌아감.
    - BUT 웹 컨테이너가 제공하는 결합분리 전략은 완벽과 거리가 멈.
    - 서블릿 프로그래머는 동시성을 정확히 구현하도록 주의를 기울여야 함.
- 구조적 개선만을 위해 동시성을 채택하는 것은 아님.
- 어떤 시스템은 응답 시간과 작업 처리량 개선이라는 요구사항으로 인해 동시성 구현을 꼭 해야함.

### 미신과 오해

다음은 동시성과 관련한 일반적인 미신과 오해다.

- **동시성은 항상 성능을 높여준다?**
    
    때로는 높여줌. 여러 스레드가 프로세서를 공유할 수 있거나, 여러 프로세서가 동시에 처리할 계산이 많은 경우. BUT 일상적으로 발생하는 상황은 아님.
    
- **동시성을 구현해도 설계는 변하지 않는다?**
    
    단일 스레드 시스템과 다중 스레드 시스템은 설계가 판이하게 다름. 일반적으로 **무엇**과 **언제**를 분리하면 시스템 구조가 크게 달라짐.
    
- **웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다?**
    
    실제로는 어떻게 컨테이너가 동작하는지, 어떻게 동시 수정, 데드락 등과 같은 문제를 피할 수 있는지 알아야 함.
    

다음은 동시성과 관련된 타당한 생각 몇 가지다.

- **동시성은 다소 부하를 유발한다.**
- **동시성은 복잡하다.** 간단한 문제라도 동시성은 복잡하다.
- **일반적으로 동시성 버그는 재현하기 어렵다.**
- **동시성을 구현하려면 흔히 근본적인 설계 전략을 재고해야 한다.**

## 📌 난관

동시성을 구현하기 어려운 이유는 무엇일까? 

- 다음 클래스를 보자.
    
    ```jsx
    public class X {
    	private int lastIdUsed;
    
    	public int getNextId() {
    		return ++lastIdUsed;
    	}
    }
    ```
    
    - 인스턴스 X 생성 후 lastIdUsed 필드를 42로 설정한 다음, 두 스레드가 해당 인스턴스 공유
    - 이제 getNextId()를 호출한다면 결과는 셋 중 하나다.
        - 한 스레드는 43을 받는다. 다른 스레드는 44를 받는다. lastIdUsed == 44
        - 한 스레드는 44를 받는다. 다른 스레드는 43을 받는다. lastIdUsed == 44
        - 한 스레드는 43을 받는다. 다른 스레드는 43을 받는다. lastIdUsed == 43
    - 두 스레드가 같은 변수 동시 참조 → 문제가 생길 수 있음.
- 두 스레드가 자바 코드 한 줄을 거쳐가는 경로가 수없이 많은데, 일부 경로가 잘못된 결과를 내놓음.
- 대다수 경로는 올바른 결과를 내놓지만 문제는 잘못된 결과를 내놓는 일부 경로

## 📌 동시성 방어 원칙

### 1) 단일 책임 원칙(SRP)

- 단일책임원칙 : 주어진 메서드, 클래스, 컴포넌트를 변경할 이유가 하나여야 한다는 원칙
- 동시성은 복잡성 하나만으로 따로 분리할 이유가 충분
    
    ⇒ 동시성 관련 코드는 다른 코드와 분리해야 함.
    
- 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있음.
- 동시성 코드는 독자적인 난관이 있음. 다른 코드에서 겪는 난관과 다르며 훨씬 어려움.

### 2) 따름 정리(collorally) : 자료 범위를 제한하라

- 공유 객체를 사용하는 코드 내 임계 영역을 synchronized 키워드로 캡슐화하여 보호해야 한다.
- 이런 임계 영역의 수를 줄이는 기술도 중요
- 공유 자료를 수정하는 위치가 많을수록 위험성도 커짐.
- **자료 사본을 공유하라**
    - 공유 자료를 줄이려면 처음부터 사용하지 않는 방법이 제일 좋음.
    - 객체를 복사해 읽기 전용으로 사용하거나 사용 후 결과를 가져오지 않는 방법도 가능
- 스레드는 가능한 독립적으로 구현하라
    - 다른 스레드와 자료 공유 X
    - 각 스레드는 클라이언트 요청 하나 처리
 
### 3) 따름정리 : 자료 사본을 사용하라

- 공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 제일 좋음.

### 3) 따름정리 : 자료 사본을 사용하라

- 공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 제일 좋음.
- 어떤 경우에는 개객체를 복사해 읽기 전용으로 사용하는 방법 가능
- 각 스레드가 객체를 복사해 사용한 후 한 스레드가 해당 사본에서 결과를 가져오는 방법 가능
- 공유 객체를 피해야 코드가 문제를 일으킬 가능성이 낮아짐.
- 사본으로 동기화를 피할 수 있다면 피해라.

### 4) 따름 정리 : 스레드는 가능한 독립적으로 구현하라

> 자신만의 세상에 존재하는 스레드를 구현한다.
> 
- 다른 스레드와 자료 공유 X
- 각 스레드는 클라이언트 요청 하나 처리
- 모든 정보는 비공유 출처에서 가져오며 로컬 변수에 저장

> **권장사항** : 독자적인 스레드로, 가능하면 다른 프로세서에서, 돌려도 괜찮도록 자료를 독립적인 단위로 분할하라.
> 

## 📌 라이브러리를 이해하라

자바5로 스레드 코드 구현할 때 고려해야 할 것은 다음과 같음.

- 스레드 환경에 안전한 컬렉션을 사용한다. 자바 5부터 제공함.
- 서로 무관한 작업 수행할 때는 executor 프레임워크 사용해
- 가능하다면 스레드가 차단되지 않는 방법 사용
- 일부 클래스 라이브러리는 스레드에 안전하지 못함.

### 스레드 환경에 안전한 컬렉션

- 자바 초창기에 만들어진 스레드에 사용해도 안전한 컬렉션
    - 나중에 java.util.concurrent 패키지에 추가 ← 다중 스레드 환경에서 사용해도 안전하고 성능도 굿
    - ex) ConcurrentHashMap 이 HashMap보다 빠름.
- 복잡한 동시성 설계를 지원하고자 만들어진 클래스 : ReentrantLock, Semaphore, CountDownLatch

> **권장사항** : 언어가 제공하는 클래스를 검토하라. 자바에서는  `java.util.concurrent` ,  `java.util.concurrent.atomic`,  `java.util.concurrent.locks`를 익혀라
> 

## 📌 실행 모델을 이해하라

- 다중 스레드를 이해하기 위한 기본 용어
    - 한정된 자원
    - 상호배제
    - 기아
    - 데드락
    - 라이브락
- 다중 스레드 프로그래밍에서 사용하는 실행 모델을 살펴보자.

### 1) 생산자-소비자(Producer-Consumer)

- 하나 이상 생산자 스레드가 정보를 생성해 버퍼나 대기열에 넣는다.
- 하나 이상 소비자 스레드가 대기열에서 정보 가져와 사용
- 생산자 스레드와 소비자 스레드가 사용하는 대기열은 **한정된 자원**임.
- 잘못하면 생산자 스레드와 소비자 스레드가 둘다 진행 가능함에도 불구하고 동시에 서로에게서 시그널을 기다릴 가능성 존재

### 2) 읽기-쓰기(Readers-Writers)

- 가정 : 읽기 스레드를 위한 주된 정보원으로 공유 자원을 사용하지만 쓰게 스레드가 공유 자원을 이따금 갱신
- 문제의 핵심 : 처리율의 문제
- 처리율을 강조하면 기아 현상이 생기거나 오래된 정보가 쌓인다.
- 대개는 쓰기 스레드가 버퍼를 오랫동안 점유하는 바람에 여러 읽기 스레드가 버퍼를 기다리느라 처리율이 떨어짐.
- 대안(1)  : 읽기 스레드가 없을 때까지 갱신을 원하는 쓰게 스레드가 버퍼를 기다림.
    - 문제 : 읽기 스레드가 계속 이어진다면 쓰기 스레드가 기아 상태에 빠짐
- 대안(2) : 쓰기 스레드에게 우선권을 준 상태에서 쓰게 스레드가 계속 이어짐.
    - 문제 : 처리율이 떨어짐.
- 양쪽 균형을 잡으면서 동시 갱신 문제 피하는 해법 필요

### 3) 식사하는 철학자들(Dining Philosophers)

- 서로 부딪히면 안되지만 양손에 포크를 집어야만 식사할 수 있는 생각 많은 철학자들이 포크를 언제 잡을지 눈치보는 거
- 포크 : 자원 / 철학자 : 스레드
- 다중 스레드 문제와 비슷 (데드락, 라이브락, 처리율 저하, 효율성 저하)

### 동기화하는 메서드 사이에 존재하는 의존성을 이해하라

- 의존성이 존재하면 버그 생김.
- 자바에는 개별 메서드를 보호하는 `synchronized`라는 개념 지원
- BUT 공유 클래스 하나에 동기화된 메서드가 여러 개라면 구현 올바른지 확인 필요

> **권장사항** : 공유 객체 하나에는 메서드 하나만 사용하라
> 
- 공유 객체 하나에 여러 메서드가 필요한 상황에 사용하는 세 가지 방법
    - 클라이언트에서 잠금
    - 서버에서 잠금
    - 연결(Adapted) 서버

## 📌 동기화하는 부분을 작게 만들어라

- 락은 스레드를 지연시키고 부하 가중
    
    ⇒ `synchronized` 문 남발하지 마라.
    
- 반면, 임계영역은 반드시 보호해야 함.
    
    ⇒ 임계영역 수를 최대한 출여야 함.
    
- 그렇다고 필요 이상으로 임계영역을 키우지는 마라. 스레드 간 경쟁이 늘어나고 성능도 떨어짐.

> **권장사항** : 동기화하는 부분을 최대한 작게 만들어라.
> 

## 📌 올바른 종료 코드는 구현하기 어렵다

- 깔끔하게 종료하는 코드는 올바로 구현하기 어려움. (데드락 문제 발생)
    
    ⇒ 스레드가 절대 오지 않을 시그널을 기다림.
    
- 깔끔하게 종료하는 다중 스레드 코드를 짜야한다면 시간을 투자해 **올바로 구현**하기 바람.

> **권장사항** : 종료 코드를 개발 초기부터 고민하고 동작하게 초기부터 구현하라.
> 

## 📌 스레드 코드 테스트하기

- 테스트가 정확성을 보장하지는 않지만 충분한 테스트는 위험을 낮춘다.
- 그런데 같은 코드와 같은 자원을 사용하는 스레드가 둘 이상으로 늘어나면 고려할 사항이 아주 많음.

> **권장사항** : 문제를 노출하는 테스트 케이스를 작성하라. 프로그램 설정과 시스템 설정과 부하를 바꿔가며 자주 돌려라. 다시 돌렸더니 통과하더라는 이유로 그냥 넘어가면 절대로 안된다.
> 
- 구체적인 지침
    - 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라
    - 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자.
    - 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있도록 스레드 코드를 구현하라.
    - 다중 스레드를 쓰는 코드 부분을 상황에 맞춰 조정할 수 있게 작성하라.
    - 프로세서 수보다 많은 스레드를 돌려보라.
    - 다른 플랫폼에서 돌려보라.
    - 코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라.

### 1) 말이 안되는 실패는 잠정적인 스레드 문제로 취급하라

- 시스템 실패를 일회성 문제라고 치부하지 마라.

### 2) 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자

- 스레드 환경 밖에서 생기는 버그와 스레드 환경에서 생기는 버그를 동시에 디버깅하지 마라. 먼저 스레드 환경 밖에서 코드를 올바로 돌려라.

### 3) 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있도록 스레드 코드를 구현하라

- 다중 스레드를 쓰는 코드를 다양한 설정으로 실행하기 쉽게 구현하라.
    - 한 스레드로 실행하거나, 여러 스레드로 실행하거나, 실행 중 스레드 수를 바꿔본다.
    - 스레드 코드를 실제 환경이나 테스트 환경에서 돌려본다.
    - 테스트 코드를 빨리, 천천히, 다양한 속도로 돌려본다.
    - 반복 테스트가 가능하도록 테스트 케이스 작성

### 4) 다중 스레드를 쓰는 코드 부분을 상황에 맞춰 조정할 수 있게 작성하라

- 처음부터 다양한 설정으로 프로그램의 성능 측정 방법을 강구한다.
- 스레드 개수를 조율하기 쉽게 코드 구현

### 5) 프로세서 수보다 많은 스레드를 돌려보라

- 스와핑이 잦을수록 임계영역을 빼먹은 코드나 데드락을 일으키는 코드를 찾기 쉬워짐

### 6) 다른 플랫폼에서 돌려보라

- 처음부터 그리고 자주 모든 목표 플랙폼에서 코드를 돌려라

### 7) 코드에 보조 코드를 넣어 돌려라. 강제로 실패를 일으키게 해보라

- 코드에 보조 코드를 추가하는 방법
    - 직접 구현하기
    - 자동화

***직접구현하기***

코드에 직접 wait(), sleep(), yield(), priority() 함수 추가

***자동화***

- AOF, CGLIB, ASM 등과 같은 도구 사용

> **권장사항** : 흔들기 기법을 사용해 오류를 찾아내라.
> 

## 📌 결론

- 원래 다중 스레드가 어려움.
- SRP를 준수해야 하고 오류를 일으키는 잠정적인 원인을 철저히 이해하자.
- 시간을 들여 보조 코드를 추가하면 오류가 드러날 가능성이 크게 높아짐.
